---
stand_alone: true
ipr: trust200902
docname: draft-toutain-t2t-sid-extension
cat: std
pi:
  symrefs: 'yes'
  sortrefs: 'yes'
  strict: 'yes'
  compact: 'yes'
  toc: 'yes'

title: SID Extention to efficiently manipulate YANG Data Models
abbrev: SID Extention
wg: t2t Research Group
author:
- ins: L. Toutain
  name: Laurent Toutain
  org: Institut MINES TELECOM; IMT Atlantique
  street:
  - 2 rue de la Chataigneraie
  - CS 17607
  city: 35576 Cesson-Sevigne Cedex
  country: France
  email: Laurent.Toutain@imt-atlantique.fr
- ins: M. Gudi
  name: Manoj Gudi
  org: Institut MINES TELECOM; IMT Atlantique
  street:
  - 2 rue de la Chataigneraie
  - CS 17607
  city: 35576 Cesson-Sevigne Cedex
  country: France
  email: manoj.gudi@imt-atlantique.net
normative:  
  RFC2119:
  RFC7951:
  RFC9254:
  I-D.ietf-core-sid:

--- abstract

   blabla



--- middle

# Introduction

YANG modeling language is very popular for node configuration and retrieving the the state of a device.  
XML and JSON are also to popular way to serialize the data model. Recently a new serialization format has
been published, allowing a more compact representation of the information. This new format is based on CBOR
and the YANG identifier instead of been represented by a unique ASCII string, are mapped to an unique integer.

The mapping between strings and integer is kept in a .sid file usually generated by tools such as pyang.

This document presents some extensions to the sid files, to ease the conversion between CBOR and JSON and also 
to manipulate YANG Data Model in a constraint environment. 

# YANG Data model

A YANG is a modeling language to structure the information and check its conformity. Each element of a YANG Data Model
is identified through an unique identifier. YANG is based on a hierarchical approach. During the serialization phase, 
data are represented either in XML or JSON. In this part we will use the JSON representation. {{RFC7951}} indicates how to 
to form a JSON structure conform to a YANG Data Model:

* Leaves are represented as JSON objects, the key being the leaf name.
* Lists are defined through arrays, 
* Identityref is a string0 containing the identifier in the YANG naming hierarchy to an identity,
* ...

The YANG Data Model, in {{Fig-YDM}}, is used to illustrate how data will be serialized. It defines a container
representing a physical object able to perform several measurements. The physical object is battery powered has a status led able 
to change color, and a list of attached sensors returning a integer value. 

~~~~
<CODE BEGINS> file "sensor.yang"
{::include sensor.yang}
<CODE ENDS>
~~~~
{: #Fig-YDM title="Example of a YANG Data Model for sensors"}

The YANG tree regarding this Data Model is given {{Fig-YANG-tree}}, the tree displays the module hierarchy. For the module "sensor", a container "sensorObject" contains two leaves ("statusLED", "battery") and a list "sensorReadings".

~~~~
$ pyang -f tree sensor.yang 
module: sensor
  +--rw sensorObject
     +--rw statusLED?        enumeration
     +--rw battery?          battery-level
     +--rw sensorReadings* [index]
        +--rw index          uint8
        +--rw sensorValue?   uint32
~~~~
{: #Fig-YANG-tree title="YANG tree associated to the DM."}

# JSON serialization

An example of data, serialized with JSON, and conform to the YANG Data Model, is given {{Fig-JSON}}. Embedded JSON Objects allows 
to represent the hierarchy. The key of the outer JSON Object is composed of the module name and the container name. The embedded JSON Object associated to this this contains the leaves as keys. The YANG list is represented by an JSON Array.

~~~~
{
  "sensor:sensorObject": {
    "statusLED": "green",
    "battery": "sensor:med-level",
    "sensorReadings": [
      {
        "index": 0,
        "sensorValue": 42
      },
      {
        "index": 1,
        "sensorValue": 22
      }
    ]
  }
}
~~~~
{: #Fig-JSON title="JSON structure conform to the YANG DM."}

# CBOR Serialization

JSON notation is verbose for constrained networks and objects. To optimize the size of the representation, {{RFC9254}} defines a CBOR serialization also called CORECONF. YANG ASCII identifiers are replaced by unique number. In JSON, the uniqueness is guaranteed by the "namespace" URI, as shown in {{Fig-YDM}}, by construction the rest of the identifiers are unique.

In CORECONF, the uniqueness is guaranteed through the use of positive integers called SID, which replaces the ASCII identifiers.  {{I-D.ietf-core-sid}} defines the allocation process. Module developers may ask for a SID range from their authority. For example, for an IETF module, the IANA will allocate a SID range. 

The  {{Fig-SID-Alloc}} shows an example of this conversion. The range is arbitrarily fixed between 60000 and 60099. Note that the module, the identity and the leaves have an assigned SID. 

~~~~
$ pyang --sid-generate-file=60000:100 --sid-list sensor.yang 

SID        Assigned to
---------  --------------------------------------------------
60000      module sensor
60001      identity battery-indicator-base-type
60002      identity high-level
60003      identity low-level
60004      identity med-level
60005      data /sensor:sensorObject
60006      data /sensor:sensorObject/battery
60007      data /sensor:sensorObject/sensorReadings
60008      data /sensor:sensorObject/sensorReadings/index
60009      data /sensor:sensorObject/sensorReadings/sensorValue
60010      data /sensor:sensorObject/statusLED

File sensor@unknown.sid created
Number of SIDs available : 100
Number of SIDs used : 11
~~~~
{: #Fig-SID-Alloc title="JSON structure conform to the YANG DM."}

To perform the allocation, the pyang command generates a .sid file in the JSON format, resulting itself of a YANG Data Model specified in {{I-D.ietf-core-sid}}. The {{Fig-SID-file}} gives an excerpt. 

~~~~
{
  "assignment-range": [
    {
      "entry-point": 60000,
      "size": 100
    }
  ],
  "module-name": "sensor",
  "module-revision": "unknown",
  "item": [
    {
      "namespace": "module",
      "identifier": "sensor",
      "status": "unstable",
      "sid": 60000
    },
    {
      "namespace": "identity",
      "identifier": "battery-indicator-base-type",
      "status": "unstable",
      "sid": 60001
    },
    ...
~~~~
{: #Fig-SID-file title="JSON structure conform to the YANG DM."}

The serialization in CBOR of the JSON example {{Fig-JSON}} is given {{Fig-CBOR}}. Compared a compacted representation of the JSON structure (152 Bytes), the CORECONF structure is 24 byte long. If the size is different, the structure is the same. It is composed of embedded CBOR Maps (equivalent of JSON Object). The first key is a SID (60005 correspond to the container). Embedded CBOR Maps uses a delta notation to encode the keys. The key 5 correspond to SID 60005+5, so to the leaf "statusLED". Key 2 in the second CBOR Map corresponds the YANG list "sensorReadings", the elements of the list are stored in a CBOR Array.

Note that in this example, the enum for "statusLED" (60005+5) is an integer and the identityref for "battery" (60005+1) is also an integer pointing to the  SID "med-level" (60004).

~~~~
b'a119ea65a305000119ea640282a2010002182aa201010216'

Diagnostic notation:
{60005: 
  {5: 0, 
   1: 60004, 
   2: [
     {1: 0, 
      2: 42}, 
     {1: 1, 
      2: 22}
     ]
  }
}
~~~~
{: #Fig-CBOR title="JSON structure conform to the YANG DM."}

# Conversion between JSON and CBOR

Even if the conversion between CBOR and JSON formats may look obvious, the conversion between these two formats coding data compatible with a YANG Data Model is not so trivial. The reason is that JSON uses ASCII identifiers for readability and CBOR prefers integers for compactness. The following table shows how YANG basic types are converted. 

| YANG  | JSON | CBOR | 
| int8  |      |      |
| int16 |      |      |
| int32 |      |      |
| int64 |      |      |