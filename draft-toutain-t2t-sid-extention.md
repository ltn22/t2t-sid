---
stand_alone: true
ipr: trust200902
docname: draft-toutain-t2t-sid-extension
cat: std
pi:
  symrefs: 'yes'
  sortrefs: 'yes'
  strict: 'yes'
  compact: 'yes'
  toc: 'yes'

title: SID Extention to efficiently manipulate YANG Data Models
abbrev: SID Extention
wg: t2t Research Group
author:
- ins: L. Toutain
  name: Laurent Toutain
  org: Institut MINES TELECOM; IMT Atlantique
  street:
  - 2 rue de la Chataigneraie
  - CS 17607
  city: 35576 Cesson-Sevigne Cedex
  country: France
  email: Laurent.Toutain@imt-atlantique.fr
- ins: M. Gudi
  name: Manoj Gudi
  org: Institut MINES TELECOM; IMT Atlantique
  street:
  - 2 rue de la Chataigneraie
  - CS 17607
  city: 35576 Cesson-Sevigne Cedex
  country: France
  email: manoj.gudi@imt-atlantique.net
- ins: J. A. Fernandez
  name: Javier A. Fernandez
  org: Institut MINES TELECOM; IMT Atlantique
  street:
  - 2 rue de la Chataigneraie
  - CS 17607
  city: 35576 Cesson-Sevigne Cedex
  country: France
  email: javier-alejandro.fernandez@imt-atlantique.fr 
normative:  
  RFC2119:
  RFC7228:
  RFC7951:
  RFC8949:
  RFC9254:
  I-D.ietf-core-sid:
  I-D.ietf-core-comi:

--- abstract

As the Internet of Things (IoT) systems are becoming more pervasive with their rapid adoption, they are also becoming more complex in their architecture. Hence, a tool is required to generate prototype code based on the YANG models for constrained devices {{RFC7228}}  to improve interoperability and increase the reusability of software components. A novel approach is introduced in this document to generate software prototypes (also called stubs) in the C language for the CORECONF protocol {{I-D.ietf-core-comi}} using YANG Schema Item iDentifiers (YANG SID {{I-D.ietf-core-sid}}). These stubs greatly reduce the complexity of navigating the CORECONF structure by abstracting the corresponding YANG SIDs. This document elaborates the procedure to generate YANG SIDs for a given YANG model of a system, then generates C stubs using the tools developed by the authors with the help of an example (sensor.yang file).

--- middle

# Introduction

YANG modeling language is very popular for node configuration and retrieving the the state of a device.  
XML and JSON are also to popular way to serialize data in conformance with the data model. Recently a 
new serialization format has
been published, allowing a more compact representation of the information. This new format is based on CBOR
and the YANG identifier instead of been represented by a unique ASCII string, are mapped to an unique integer.

The mapping between strings and integer is kept in a .sid file usually generated by tools such as pyang.

This document presents some extensions to the sid files, to ease the conversion between CBOR and JSON and also 
to manipulate YANG Data Model in a constraint environment. 

# YANG Data model

A YANG is a modeling language to structure the information and check its conformity. Each element of a YANG Data Model
is identified through an unique identifier. YANG is based on a hierarchical approach. During the serialization phase, 
data are represented either in XML or JSON. In this part we will use the JSON representation. {{RFC7951}} indicates how to 
to form a JSON structure conform to a YANG Data Model:

* Leaves are represented as JSON objects, the key being the leaf name.
* Lists are defined through arrays, 
* Identityref is a string containing the identifier in the YANG naming hierarchy to an identity.

The YANG Data Model, in {{Fig-YDM}}, is used to illustrate how data will be serialized. It defines a container
representing a physical object able to perform several measurements. The physical object is battery powered has a status led able 
to change color, and a list of attached sensors returning a integer value. 

~~~~
<CODE BEGINS> file "sensor.yang"
{::include sensor.yang}
<CODE ENDS>
~~~~
{: #Fig-YDM title="Example of a YANG Data Model for sensors"}

The YANG tree regarding this Data Model is given {{Fig-YANG-tree}}, the tree displays the module hierarchy. For the module "sensor", a container "sensorObject" contains two leaves ("statusLED", "battery") and a list "sensorReadings".

~~~~
$ pyang -f tree sensor.yang 
module: sensor
  +--rw sensorObject
     +--rw statusLED?        enumeration
     +--rw battery?          battery-level
     +--rw sensorReadings* [index]
        +--rw index          uint8
        +--rw sensorValue?   uint32
~~~~
{: #Fig-YANG-tree title="YANG tree associated to the DM."}

# JSON serialization

An example of data, serialized with JSON, and conform to the YANG Data Model, is given {{Fig-JSON}}. Embedded JSON Objects allows 
to represent the hierarchy. The key of the outer JSON Object is composed of the module name and the container name. The embedded JSON Object associated to this  contains the leaves as keys. The YANG list is represented by an JSON Array.

~~~~
{
  "sensor:sensorObject": {
    "statusLED": "green",
    "battery": "sensor:med-level",
    "sensorReadings": [
      {
        "index": 0,
        "sensorValue": 42
      },
      {
        "index": 1,
        "sensorValue": 22
      }
    ]
  }
}
~~~~
{: #Fig-JSON title="JSON structure conform to the YANG DM."}

# CBOR Serialization

JSON notation is verbose for constrained networks and objects. To optimize the size of the representation, {{RFC9254}} defines a CBOR serialization also called CORECONF. YANG ASCII identifiers are replaced by unique number. In JSON, the uniqueness is guaranteed by the "namespace" URI, as shown in {{Fig-YDM}}, by construction the rest of the identifiers are unique.

In CORECONF, the uniqueness is guaranteed through the use of positive integers called SID, which replaces the ASCII identifiers.  {{I-D.ietf-core-sid}} defines the allocation process. Module developers may ask for a SID range from their authority. For example, for an IETF module, the IANA will allocate a SID range. 

The  {{Fig-SID-Alloc}} shows an example of this conversion. The range is arbitrarily fixed between 60000 and 60099. Note that the module, the identities and the leaves have an assigned SID. 

~~~~
$ pyang --sid-generate-file=60000:100 --sid-list sensor.yang 

SID        Assigned to
â€‹---------  --------------------------------------------------
60000      module sensor
60001      identity battery-indicator-base-type
60002      identity high-level
60003      identity low-level
60004      identity med-level
60005      data /sensor:sensorObject
60006      data /sensor:sensorObject/battery
60007      data /sensor:sensorObject/sensorReadings
60008      data /sensor:sensorObject/sensorReadings/index
60009      data /sensor:sensorObject/sensorReadings/sensorValue
60010      data /sensor:sensorObject/statusLED

File sensor@unknown.sid created
Number of SIDs available : 100
Number of SIDs used : 11
~~~~
{: #Fig-SID-Alloc title="JSON structure conform to the YANG DM."}

To perform the allocation, the pyang command generates a .sid file in the JSON format, resulting itself of a YANG Data Model specified in {{I-D.ietf-core-sid}}. The {{Fig-SID-file}} gives an excerpt. 

~~~~
{
  "assignment-range": [
    {
      "entry-point": 60000,
      "size": 100
    }
  ],
  "module-name": "sensor",
  "module-revision": "unknown",
  "item": [
    {
      "namespace": "module",
      "identifier": "sensor",
      "status": "unstable",
      "sid": 60000
    },
    {
      "namespace": "identity",
      "identifier": "battery-indicator-base-type",
      "status": "unstable",
      "sid": 60001
    },
    ...
~~~~
{: #Fig-SID-file title="JSON structure conform to the YANG DM."}

The serialization in CBOR of the JSON example {{Fig-JSON}} is given {{Fig-CBOR}}. Compared a compacted representation of the JSON structure (152 Bytes), the CORECONF structure is 24 byte long. If the size is different, the structure remains the same. It is composed of embedded CBOR Maps (equivalent of JSON Object). The first key is a SID (60005 correspond to the container). Embedded CBOR Maps uses a delta notation to encode the keys. The key 5 correspond to SID 60005+5, so to the leaf "statusLED". Key 2 in the second CBOR Map corresponds the YANG list "sensorReadings", the elements of the list are stored in a CBOR Array.

Note that in this example, the enum for "statusLED" (60005+5) is an integer and the identityref for "battery" (60005+1) is also an integer pointing to the  SID "med-level" (60004).

~~~~
b'a119ea65a305000119ea640282a2010002182aa201010216'

Diagnostic notation:
{60005: 
  {5: 0, 
   1: 60004, 
   2: [
     {1: 0, 
      2: 42}, 
     {1: 1, 
      2: 22}
     ]
  }
}
~~~~
{: #Fig-CBOR title="JSON structure conform to the YANG DM."}

# Conversion between JSON and CBOR

Even if the conversion between CBOR and JSON formats may look obvious, the conversion between these two formats coding data compatible with a YANG Data Model is not so trivial. The reason is that JSON uses ASCII identifiers for readability and CBOR prefers integers for compactness.  The {{Tab-types}} summarizes some YANG types when coded in JSON ({{RFC7951}}) or CBOR ({{RFC8949}}).

| YANG                | JSON     | CBOR | 
|---------------------|----------|-----------|
| int8, int16, int32, uint8, uint16, uint32   | number     |  +int, -int    |
|  int64, uint64      | string      | +int, -int     |
|  decimal64          | string      | CBOR Tag 4     |
| binary              | base64     |  byte array    |
| bits                | string     |  array    |
| boolean             | boolean     |  boolean    |
| identityref         | string     |  +int    |
| enumeration         | string     | +int |
{: #Tab-types title="YANG basic types in JSON and CBOR."}

The conversion for CBOR to JSON is not direct, the YANG type needs to be consider. For instance a integer could be converted into a number, an enum or an identityref. Note that for union, the conversion is simple since some CBOR Tags may be used to indicate how the integer is converted, but outside of the union, for a single value, there is no such clue.

On the other direction, a JSON string may correspond to a 64 bit long number, an enumeration, an identityref.

To perform the conversion, the YANG type is needed. But, popular tools such as yanglint or pyang are not currently manipulating CBOR representation. Futhermore, these tools cannot run on constrained devices. To overcome these problems, we propose to extend the .sid file with more information. The modified the pyang code (see https://github.com/ltn22/pyang/tree/sid-extension) adding some information to the .sid file when "--sid-extension" argument is provided.

This extension contains a "type" key in the JSON Object describing the mapping between the SID and the identifier, if the node is a leaf (see {{Fig-SID-extension}}).


~~~~
...
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject",
      "status": "unstable",
      "sid": 60005
    },
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject/battery",
      "status": "unstable",
      "sid": 60006,
      "type": "identityref"
    },
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject/sensorReadings",
      "status": "unstable",
      "sid": 60007
    },
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject/sensorReadings/index",
      "status": "unstable",
      "sid": 60008,
      "type": "uint8"
    },
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject/sensorReadings/sensorValue",
      "status": "unstable",
      "sid": 60009,
      "type": "uint32"
    },
    {
      "namespace": "data",
      "identifier": "/sensor:sensorObject/statusLED",
      "status": "unstable",
      "sid": 60010,
      "type": {
        "0": "green",
        "1": "yellow",
        "2": "red"
      }
    }
...
~~~~
{: #Fig-SID-extension title="SID "type" extension."}

The "type" key added to leaf nodes contains several information:

* when the "type" key is not present, the node is a not leaf and there is no need for type conversion.
* when the type of "type" is a string, it gives the YANG type of the leaf, as defined in the YANG Data Model. If the YANG type derives from an identityref, the value "identityref" is given instead of the YANG type specified in the module. In that case, in the CBOR notation, the have a pair "{ ...., SID1: value1, ...} in the CBOR Map. A first lookup at the .sid file for SID1 returns that the type is "identityref", a second lookup for value1 in the "identity" namespace, returns the ASCII identifier. 
* when the type of "type" is an JSON Object, then the leaf is an YANG enumeration, an the CBOR Map gives the mapping between integer and strings.
* when the type of "type" is a JSON Array, then the YANG leaf is a union. Elements of the Array list the possible types. In that case, the conversion is leaded by the CBOR Tags associated to the value. 

<!-- Should be https://github.com/alex-fddz/pycoreconf, some bugs items => item and pb with self.name -->
We developed the pycoreconf Python module to facilitate the conversion between JSON and CBOR (https://github.com/ltn22/pycoreconf). The {{Fig-pcc-ex}} gives an example of a Python script using this module. It takes in input, the .sid file and a JSON structure. It transforms it into a CBOR structure, and back to JSON representation.

~~~~ python
# pycoreconf sample: "basic"
# This script demonstrates the basic usage of pycoreconf
#  using a simple YANG datamodel.

import pycoreconf
import binascii
import cbor2 as cbor

# Create the model object
ccm = pycoreconf.CORECONFModel("sensor@unknown.sid")

# Read JSON configuration file
config_file = "output.json"

with open(config_file, "r") as f:
    json_data = f.read()
print("Input JSON config data =\n", json_data, sep='')

# Convert configuration to CORECONF/CBOR
cbor_data = ccm.toCORECONF(config_file) # can also take json_data
print("Encoded CBOR data (CORECONF payload) =", binascii.hexlify(cbor_data))
print (cbor.loads(cbor_data))

# Decode CBOR data back to JSON configuration data
decoded_json = ccm.toJSON(cbor_data)
print("Decoded config data =", decoded_json)
~~~~
{: #Fig-pcc-ex title="pycoreconf module."}

The result with the JSON structure of {{Fig-JSON}} is given {{Fig-pcc-res}}. It shows that the JSON format can be converted in CBOR and vice versa, just by using the extended .sid file.

~~~~ 
Input JSON config data =
{
  "sensor:sensorObject": {
    "statusLED": "green",
    "battery": "sensor:med-level",
    "sensorReadings": [
      {
        "index": 0,
        "sensorValue": 42
      },
      {
        "index": 1,
        "sensorValue": 22
      } 
    ]
  }
}

Encoded CBOR data (CORECONF payload) = b'a119ea65a305000119ea640282a2010002182aa201010216'
{60005: {5: 0, 1: 60004, 2: [{1: 0, 2: 42}, {1: 1, 2: 22}]}}
Decoded config data = {"sensor:sensorObject": {"statusLED": "green", "battery": "med-level", "sensorReadings": [{"index": 0, "sensorValue": 42}, {"index": 1, "sensorValue": 22}]}}
~~~~
{: #Fig-pcc-res title="pycoreconf module."}


# Navigating the CORECONF structure.

As we saw, the CORECONF data  is structured as a tree. The {{Fig-coreconf-ex}} gives an example for the example module described {{Fig-YDM}}. The numbers are the SID associated to the YANG Data Model. {{I-D.ietf-core-comi}} defines how queries are made on this structure to get the full tree or a sub tree.


~~~~~~ aasvg
                      sensorObject
                         60005
           battery     LED |    sensorReadings
                +----------+----------+
                |          |          |
              60006      60010      60007
                                      |
               +-----------+----------+-----------+ 
        index  |           |          |           |  sensorValue
        +---------+ +----------+ +----------+ +----------+     
        |         | |          | |          | |          |
        60008 60009 60008  60009 60008  60009 60008  60009                                 

~~~~~~
{: #Fig-coreconf-ex title="pycoreconf module."}

Requesting the SID corresponding to the module (60005), will return the full tree. Requesting "battery" leaf (60006) will return the leaf and the associated value, as well as Requesting "sensorReadings" (60007) will return the subtree will all the values. Going deeper in this sub-tree impose the use of keys. For instance to get a specific "sensorValue" imposes to provide the key "index" (60008).

In {{I-D.ietf-core-comi}}, the series of keys needed to reach a specific element is provided either in the query string or in the fetch. Only one list is provided in {{Fig-coreconf-ex}}, but several lists can be embedded, and each level may require one or more keys. So, to be processed, the YANG Data Model as to be known. 

To avoid the parsing of the YANG Data Model in a constrained device, we propose to summarize this information into a JSON Object, generated by pyang with the "--sid-extension" argument.

~~~~~json
  "key-mapping": {
    "60007" : 
        [60008]
  }
~~~~~
{: #Fig-key-mapping title="pycoreconf module."}

The "key-mapping" key points out to a JSON Object, where the JSON key is a SID corresponding to a YANG list key and the value is a JSON array of the SIDs acting as a YANG key for that YANG list. The "key-mapping" JSON Object indicates:

* that a SID is a YANG list, since its value appears as a JSON key in the "key-mapping" structure,
* the number of elements in the corresponding array indicates how many items are involved as a YANG list key. The value for these item can be taken from the request.
* the array indicates also which SIDs contain the value that must compared to the YANG list key sent in the request.

With the information contained in the "key-mapping" structure it is possible to browse any CORECONF structure an return the appropriate requested SID.

# Linking to real values


When querying a YANG Data Model, as the one provided in {{Fig-YDM}}, some leaves contains information that are available outside on the model itself. This can be the case of the "statusLED" leaf, where an action is require to setup the appropriate color when the leaf is write, or the "sensorValue" which interact with a physical sensor on the managed device. Other leaves, such as "index" do not require interaction, the value is directly stored in the database.

We wrote a script taking the .sid file generated with pyang and the "--sid-extension" argument to generate C code for generating template for these functions. We try keep SID transparent and uses as much as possible the YANG identifiers which are easier to manipulate by a programmer.

The idea of the tool is to create aliases for the identifiers which also contain information about their corresponding SIDs so that the developers need not remember or cross-check SIDs during the software development.


 * The tool is hosted at https://github.com/manojgudi/ccoreconf/tree/stub_generation/tools

 * For the SID file above (sensor@unknown.sid), the second argument in the command- _"sensor_prototypes"_ instructs the tool to create two files _sensor_prototypes.h_ and _sensor_prototypes.c_ for writing headers and function code  respectively. To generate code, simply run the tool:


~~~~~bash
$ python generateStubs.py sensor@unknown.sid "sensor_prototypes"
~~~~~

~~~~~ c

//Headers
//-----------
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <cbor.h>

#define  SID_BATTERY             60006
#define  SID_INDEX               60008
#define  SID_SENSORVALUE         60009
#define  SID_STATUSLED           60010


#define read_sensorObject        read_60005
#define read_battery             read_60006
#define read_sensorReadings      read_60007
#define read_sensorValue         read_60009
#define read_statusLED           read_60010

char* keyMapping = "\xa1\x19\xeag\x81\x19\xeah";
enum StatusledEnum {green = 0, yellow = 1, red = 2};

void  read_sensorObject(void);
char *  read_battery(void);
void  read_sensorReadings(uint8_t index);
uint32_t  read_sensorValue(uint8_t index);
enum StatusledEnum read_statusLED(void);
~~~~~

~~~~~C
//Code File
//-----------
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "sensor_prototypes.h"

/*
    This is an autogenerated function associated to 
    SID: 60005
    Module: data 
    Identifier: /sensor:sensorObject
    function params: 
    Stable: false
*/
void  read_sensorObject(void){
    // Initialize the leaf if it has a return type with a default value;
    // Do something with the leaf
}

/*
    This is an autogenerated function associated to 
    SID: 60006
    Module: data 
    Identifier: /sensor:sensorObject/battery
    function params: 
    Stable: false
*/
char *  read_battery(void){
    // Initialize the leaf if it has a return type with a default value;
    char * batteryInstance  = NULL;

    // Do something with the leaf
    // Return the leaf
    return batteryInstance;
}

/*
    This is an autogenerated function associated to 
    SID: 60007
    Module: data
    Identifier: /sensor:sensorObject/sensorReadings
    function params: /sensor:sensorObject/sensorReadings/index
    Stable: false
*/
void  read_sensorReadings(uint8_t index){
    // Initialize the leaf if it has a return type with a default value;
    // Do something with the leaf
}

/*
    This is an autogenerated function associated to 
    SID: 60009
    Module: data 
    Identifier: /sensor:sensorObject/sensorReadings/sensorValue
    function params: /sensor:sensorObject/sensorReadings/index
    Stable: false
*/
uint32_t  read_sensorValue(uint8_t index){
    // Initialize the leaf if it has a return type with a default value;
    uint32_t sensorValueInstance  = 0;

    // Do something with the leaf
    // Return the leaf 
    return sensorValueInstance;
}

/*
    This is an autogenerated function associated to 
    SID: 60010
    Module: data 
    Identifier: /sensor:sensorObject/statusLED
    function params: 
    Stable: false
*/
enum StatusledEnum read_statusLED(void){
    // Initialize the leaf if it has a return type with a default value;
    enum StatusledEnum statusLEDInstance;

    // Do something with the leaf
    // Return the leaf 
    return statusLEDInstance;
}
~~~~~

# Understanding Stubs

Let us take a quick look at the generated code snippet to understand how they help abstract SIDs from the developers-

The first part of the *sensor_prototypes.h* contains pre-processor directives which basically store the identifiers with their corresponding SID values for quick access. The second part contains function prototypes which can be implemented later. Note, there **wont be** any function prototype generated to read SID keys (in this case _index_ with SID 60008).

~~~~~c
// Aliases of the leaves mapped to their corresponding SID
#define  SID_BATTERY             60006
#define  SID_INDEX               60008
#define  SID_SENSORVALUE         60009
#define  SID_STATUSLED           60010

// Aliases of function prototypes linked to their function name containing SID value for quick and easy access
#define read_sensorObject        read_60005
#define read_battery             read_60006
#define read_sensorReadings      read_60007
#define read_sensorValue         read_60009
#define read_statusLED           read_60010

// The relation between certain identifiers and their sid keys is stored in keyMapping as a CBOR map
char* keyMapping = "\xa1\x19\xeag\x81\x19\xeah";
enum StatusledEnum {green = 0, yellow = 1, red = 2};

// Function prototypes of the getters which can be implemented by the developer later in its corresponding C file
// The return types of the functions are mapped according to the type of the leaf. The getters for non-leaves are mapped as void
void  read_sensorObject(void);
char *  read_battery(void);
void  read_sensorReadings(uint8_t index);
uint32_t  read_sensorValue(uint8_t index);
enum StatusledEnum read_statusLED(void);
~~~~~

 Now let us understand what is generated in *sid_prototypes.c* by looking at auto-generated function prototype *read_sensorValue*. The program auto-infers that the leaf _sensorValue_ can only be reached through a valid SID key (that is: index), so a function trying to read _sensorValue_ from its coreconf instance will require a function parameter _index_. Also since _sensorValue_ has a well-defined type in C, the function will try to return that _uint32_t_.

The program also maps _enum_ type from SID to a corresponding _enum_ type in C as shown for the leaf _statusLED_. The value of these enums is as specified in the corresponding YANG model. If unspecified, the values are auto-assigned.

 For rest of the non-leaf functions and leaves with type of _identityref_ the program infers it to be a _char *_ (since the types are non-standard).

~~~~~ c
uint32_t  read_sensorValue(uint8_t index){
    // Initialize the leaf if it has a return type with a default value;
    uint32_t sensorValueInstance  = 0;

    // Do something with the leaf
    // Return the leaf 
    return sensorValueInstance;
}
~~~~~

